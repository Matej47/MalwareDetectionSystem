import asyncio
import websockets
import subprocess
import json
import os
import shutil
import importlib.util
from datetime import datetime

server_ip = "ws://192.168.96.1:8765"
image_command = 'sudo insmod LiME/src/lime-6.5.0-25-generic.ko "path=./images/memory_image.raw format=raw"'
# Define the directory to save modules
modules_dir = "modules"
# File path to store the module priorities
module_priorities_file_path = "module_priorities.json"
modules = []


def load_modules():
    """Load analysis modules from the modules directory along with their priorities."""
    global modules

    # Load module priorities from the JSON file
    with open(module_priorities_file_path, 'r') as f:
        module_priorities = json.load(f)

    # Load modules from the specified directory
    modules = []
    for file_name in os.listdir(modules_dir):
        if file_name.endswith(".py"):
            module_name = os.path.splitext(file_name)[0]
            module_path = os.path.join(modules_dir, file_name)
            spec = importlib.util.spec_from_file_location(module_name, module_path)
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            modules.append(module)

    # Assign priorities to modules based on the JSON data
    for module_info in module_priorities['modules']:
        for module in modules:
            if module.__name__ == module_info['file_name']:
                setattr(module, 'priority', module_info.get('priority', 0))

    # Sort modules based on priority
    modules.sort(key=lambda x: getattr(x, 'priority', 0))


def execute_modules(image_file_path):
    """Execute analysis tasks defined in each module based on priority."""
    global modules

    # Load modules along with their priorities
    load_modules()

    # Dictionary to store results of each module
    module_results = {}

    # Execute modules based on priority
    for module in modules:
        result = module.analyze(image_file_path, module_results)  # Call analyze function in each module
        module_results[module.__name__] = result

    # Create the report JSON
    report = {
        "action": "report",
        "date": datetime.now().isoformat(),
        "modules": module_results
    }
    message_json = json.dumps(report)
    return message_json


def create_and_analyze_memory_image():
    """
    A placeholder for a complex operation that might involve subprocess calls,
    file I/O, CPU-bound computations, or other blocking operations.
    """
    # Example subprocess call, could be part of the complex operations
    result = await asyncio.to_thread(
        subprocess.run,
        image_command,
        shell=True,
        capture_output=True,
        text=True
    )

    # Imagine more complex logic here, involving file operations, calculations, etc.
    # ...
    image_file_path = "fake_path101"
    report = execute_modules(image_file_path)
    return report


async def analyze_and_report():
    """
    Executes the complex operation in a non-blocking way by running it in a separate thread.
    """
    print("Analyzing memory image...")
    result = await asyncio.to_thread(create_and_analyze_memory_image)
    print("Memory image done...")
    return result


async def listen_to_server(websocket):
    """
    Listens to messages from the server and reacts accordingly.
    """
    async for message in websocket:
        # Parse the JSON message
        message = json.loads(message)
        if message["action"] == "sync":
            # Extract only the required information for modules
            modules_save_list = []
            for module_data in message['modules']:
                module_info = {
                    'file_name': module_data['file_name'],
                    'active': module_data['active'],
                    'priority': module_data['priority']
                }
                modules_save_list.append(module_info)

            # Create a new dictionary containing only the modules list
            modules_json = {
                'modules': modules_save_list
            }

            # Serialize the dictionary to JSON format and write it to a file
            with open(module_priorities_file_path, "w") as file:
                json.dump(modules_json, file)

            # Clear the modules directory if it exists
            if os.path.exists(modules_dir):
                shutil.rmtree(modules_dir)
            # Ensure the directory exists, create it if it doesn't
            os.makedirs(modules_dir, exist_ok=True)
            # Process each module
            for module_info in message["modules"]:
                file_name = module_info.get("file_name")
                script_content = module_info.get("script_content")
                active = module_info.get("active")
                priority = module_info.get("priority")

                file_path = os.path.join(modules_dir, file_name)
                # Save the script content to a file
                with open(file_path, 'w') as file:
                    file.write(script_content)
        # if message == "ping":
        #     print("ping")
        #     await websocket.send("ping")
        # elif message == "mmi":
        #     await perform_heavy_operation()
        #     print("MMI")
        #     print("MMI")
        #     print("MMI")
        #     await websocket.send("Memory image operation completed")


async def autonomous_service(websocket):
    """
    An autonomous service that periodically performs a heavy operation and
    sends messages without blocking the asyncio event loop.
    """
    while True:
        # Example: Wait before performing the operation or sending a message
        await asyncio.sleep(5)

        # Performing the heavy operation
        report = await analyze_and_report()

        # Sending a message to the server indicating completion or status
        await websocket.send(str(report))


async def main():
    async with websockets.connect(server_ip) as websocket:
        # Run the autonomous service and listen to server in parallel
        listen_task = asyncio.create_task(listen_to_server(websocket))
        autonomous_task = asyncio.create_task(autonomous_service(websocket))

        # Wait for both tasks to complete
        await asyncio.gather(listen_task, autonomous_task)


if __name__ == "__main__":
    asyncio.run(main())
