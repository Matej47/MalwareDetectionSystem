import asyncio
import websockets
import threading
from PyQt5 import QtWidgets, QtCore
from gui import gui
import sys
from database_service import DatabaseService
import json
import os
from datetime import datetime

# add on/off button to modules
# visualize some statistics in data page


class CallbackHolder:
    def __init__(self):
        self.callback = None

    def set_callback(self, callback):
        self.callback = callback

    def call_callback(self, *args, **kwargs):
        if self.callback:
            self.callback(*args, **kwargs)

    def clear_callback(self):
        self.callback = None


devices = {}
device_signal = CallbackHolder()
# Initialize database service
db_service = DatabaseService()
start = datetime.now()


async def message_service(websocket, path):
    # Receive initial device_id from the client
    if websocket.remote_address[0] not in devices:
        devices[websocket.remote_address[0]] = websocket
        if not db_service.find_device_by_name(websocket.remote_address[0]):
            db_service.create_device(websocket.remote_address[0])
        # if device_signal.callback:
        #     device_signal.call_callback(websocket.remote_address[0], True)
        # print(f"New device connected with WS: {websocket.remote_address[0]}.")
    else:
        print(f"Device {websocket.remote_address[0]} reconnected.")

    # Listen for messages from the client
    try:
        async for message in websocket:
            # Parse the JSON message
            message = json.loads(message)
            if message["action"] == "report":
                db_service.save_report(websocket.remote_address[0], message)
            elif message["action"] == "ping":
                print(datetime.now() - start)
    # Remove the websocket from devices dict when the connection is closed
    finally:
        if websocket.remote_address[0] in devices:
            del devices[websocket.remote_address[0]]
            # if device_signal.callback:
            #     device_signal.call_callback(websocket.remote_address[0], False)
            # print(f"Device {websocket.remote_address[0]} disconnected.")


async def send_message_to_client(device_id, message):
    if device_id in devices:
        await devices[device_id].send(json.dumps({"action": message}))
        print(f"Message sent to {device_id}: {message}")
    else:
        print(f"Device {device_id} not found.")


async def send_modules_to_device(device_id):
    # Retrieve modules for the specified device from the database
    modules = db_service.get_modules_for_device(device_id)
    if modules:
        # Prepare the message containing module information
        module_data = []
        for module in modules:
            # Read the Python script content
            print(module.file_path)
            with open(module.file_path, 'r') as file:
                script_content = file.read()

            # Get the filename from the file path
            file_name = os.path.basename(module.file_path)

            # Prepare module info
            module_info = {
                "file_name": file_name,
                "script_content": script_content,
                "active": module.active,
                "priority": module.priority
            }
            module_data.append(module_info)

        # Convert module data to JSON format
        build_message = {"action": "sync", "modules": module_data}
        message_json = json.dumps(build_message)

        # Send the JSON message to the device
        await send_message_to_client(device_id, message_json)
    else:
        print(f"No modules found for device {device_id}")


async def sync_button_msg():
    for device_ip in devices:
        await send_modules_to_device(device_ip)


def cli():
    while True:
        cmd = input("Enter command: ")
        if cmd == "list":
            print("Connected devices:")
            for device in devices:
                print(device)
        elif cmd.startswith("send "):
            parts = cmd.split(" ", 2)  # Split the command into parts
            if len(parts) == 3:
                device_id, message = parts[1], parts[2]
                asyncio.run(send_message_to_client(device_id, message))
            else:
                print("Invalid send command. Usage: send <device_id> <message>")
        elif cmd == "gui":
            print("Opening GUI...")
            gui.run_gui(device_signal, db_service, sync_button_msg)
            device_signal.clear_callback()
            print("GUI closed")
        elif cmd.startswith("ping "):
            ip = cmd.split(" ")[1]
            for i in range(10):
                asyncio.run(send_message_to_client(ip, "ping"))
        elif cmd.startswith("get lrep"):
            ip = cmd.split(" ")[2]
            print(db_service.get_last_report_for_device(ip))
        elif cmd == "quit":
            print("Exiting CLI...")
            break
        else:
            print("Unknown command")


def run_cli_in_thread():
    cli_thread = threading.Thread(target=cli)
    cli_thread.start()


async def main():
    run_cli_in_thread()
    if db_service.find_device_by_name("server") is None:
        db_service.create_device("server")
    async with websockets.serve(message_service, "0.0.0.0", 8765):
        await asyncio.Future()  # Run forever


if __name__ == "__main__":
    asyncio.run(main())
